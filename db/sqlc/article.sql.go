// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: article.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAllArticles = `-- name: CountAllArticles :one
SELECT count(*)
FROM articles
`

func (q *Queries) CountAllArticles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllArticles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countArticles = `-- name: CountArticles :one
SELECT count(*)
FROM articles
WHERE is_publish = COALESCE($1, is_publish)
  AND category_id = COALESCE($2, category_id)
`

type CountArticlesParams struct {
	IsPublish  pgtype.Bool `json:"is_publish"`
	CategoryID pgtype.Int8 `json:"category_id"`
}

func (q *Queries) CountArticles(ctx context.Context, arg CountArticlesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countArticles, arg.IsPublish, arg.CategoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchArticles = `-- name: CountSearchArticles :one
SELECT count(*)
FROM articles a
WHERE
    (title || ' ' || summary || ' ' || content) &@~ $1::text
    AND ($2::boolean IS NULL OR a.is_publish = $2)
    AND a.deleted_at = '0001-01-01 00:00:00Z'
`

type CountSearchArticlesParams struct {
	Keyword   string      `json:"keyword"`
	IsPublish pgtype.Bool `json:"is_publish"`
}

func (q *Queries) CountSearchArticles(ctx context.Context, arg CountSearchArticlesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchArticles, arg.Keyword, arg.IsPublish)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (id,
                  title,
                  summary,
                  content,
                  is_publish,
                  owner,
                  category_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, title, summary, content, views, likes, is_publish, owner, created_at, updated_at, deleted_at, category_id
`

type CreateArticleParams struct {
	ID         uuid.UUID `json:"id"`
	Title      string    `json:"title"`
	Summary    string    `json:"summary"`
	Content    string    `json:"content"`
	IsPublish  bool      `json:"is_publish"`
	Owner      uuid.UUID `json:"owner"`
	CategoryID int64     `json:"category_id"`
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, createArticle,
		arg.ID,
		arg.Title,
		arg.Summary,
		arg.Content,
		arg.IsPublish,
		arg.Owner,
		arg.CategoryID,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Views,
		&i.Likes,
		&i.IsPublish,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CategoryID,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM articles WHERE id = $1
`

func (q *Queries) DeleteArticle(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteArticle, id)
	return err
}

const getArticle = `-- name: GetArticle :one
SELECT
a.id, a.title, a.summary, a.content, a.is_publish, a.views, a.likes, a.owner,
a.created_at, a.updated_at, a.deleted_at, a.category_id, c.name as category_name
FROM articles a
LEFT OUTER JOIN categories c on c.id = a.category_id
WHERE a.id = $1
LIMIT 1
`

type GetArticleRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Summary      string      `json:"summary"`
	Content      string      `json:"content"`
	IsPublish    bool        `json:"is_publish"`
	Views        int32       `json:"views"`
	Likes        int32       `json:"likes"`
	Owner        uuid.UUID   `json:"owner"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	DeletedAt    time.Time   `json:"deleted_at"`
	CategoryID   int64       `json:"category_id"`
	CategoryName pgtype.Text `json:"category_name"`
}

func (q *Queries) GetArticle(ctx context.Context, id uuid.UUID) (GetArticleRow, error) {
	row := q.db.QueryRow(ctx, getArticle, id)
	var i GetArticleRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.IsPublish,
		&i.Views,
		&i.Likes,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CategoryID,
		&i.CategoryName,
	)
	return i, err
}

const getArticleForUpdate = `-- name: GetArticleForUpdate :one
SELECT
    id, title, summary, content, views, likes, is_publish, owner, created_at, updated_at, deleted_at, category_id
FROM articles
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetArticleForUpdate(ctx context.Context, id uuid.UUID) (Article, error) {
	row := q.db.QueryRow(ctx, getArticleForUpdate, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Views,
		&i.Likes,
		&i.IsPublish,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CategoryID,
	)
	return i, err
}

const incrementArticleLikes = `-- name: IncrementArticleLikes :exec
UPDATE articles SET likes = likes + 1 WHERE id = $1
`

func (q *Queries) IncrementArticleLikes(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementArticleLikes, id)
	return err
}

const incrementArticleViews = `-- name: IncrementArticleViews :exec
UPDATE articles SET views = views + 1 WHERE  id = $1
`

func (q *Queries) IncrementArticleViews(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementArticleViews, id)
	return err
}

const listAllArticles = `-- name: ListAllArticles :many
SELECT a.id, title, summary, views, likes, is_publish, owner, a.created_at, a.updated_at, deleted_at, c.name as category_name
FROM articles a
LEFT JOIN categories c on c.id = a.category_id
ORDER BY a.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllArticlesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllArticlesRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Summary      string      `json:"summary"`
	Views        int32       `json:"views"`
	Likes        int32       `json:"likes"`
	IsPublish    bool        `json:"is_publish"`
	Owner        uuid.UUID   `json:"owner"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	DeletedAt    time.Time   `json:"deleted_at"`
	CategoryName pgtype.Text `json:"category_name"`
}

func (q *Queries) ListAllArticles(ctx context.Context, arg ListAllArticlesParams) ([]ListAllArticlesRow, error) {
	rows, err := q.db.Query(ctx, listAllArticles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllArticlesRow{}
	for rows.Next() {
		var i ListAllArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Views,
			&i.Likes,
			&i.IsPublish,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArticles = `-- name: ListArticles :many
SELECT a.id, a.title, a.summary, a.views, a.likes, a.is_publish, a.owner, a.created_at, a.updated_at, a.deleted_at, c.name as category_name, u.username
FROM articles a
LEFT JOIN categories c on c.id = a.category_id
LEFT JOIN users u on a.owner = u.id
WHERE
    a.is_publish = COALESCE($3, a.is_publish)
  AND a.category_id = COALESCE($4, a.category_id)
ORDER BY a.created_at DESC
LIMIT $1 OFFSET $2
`

type ListArticlesParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	IsPublish  pgtype.Bool `json:"is_publish"`
	CategoryID pgtype.Int8 `json:"category_id"`
}

type ListArticlesRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Summary      string      `json:"summary"`
	Views        int32       `json:"views"`
	Likes        int32       `json:"likes"`
	IsPublish    bool        `json:"is_publish"`
	Owner        uuid.UUID   `json:"owner"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	DeletedAt    time.Time   `json:"deleted_at"`
	CategoryName pgtype.Text `json:"category_name"`
	Username     pgtype.Text `json:"username"`
}

func (q *Queries) ListArticles(ctx context.Context, arg ListArticlesParams) ([]ListArticlesRow, error) {
	rows, err := q.db.Query(ctx, listArticles,
		arg.Limit,
		arg.Offset,
		arg.IsPublish,
		arg.CategoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListArticlesRow{}
	for rows.Next() {
		var i ListArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Views,
			&i.Likes,
			&i.IsPublish,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CategoryName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchArticles = `-- name: SearchArticles :many
SELECT a.id, a.title, a.summary, a.views, a.likes, a.is_publish, a.owner,a.created_at, a.updated_at, a.deleted_at,
       c.name as category_name, u.username, pgroonga_score(a.tableoid, a.ctid) AS score
FROM articles a
         LEFT JOIN categories c on c.id = a.category_id
         LEFT JOIN users u on a.owner = u.id
WHERE
    (title || ' ' || summary || ' ' || content) &@~ $3::text
    AND ($4::boolean IS NULL OR a.is_publish = $4)
    AND a.deleted_at = '0001-01-01 00:00:00Z'
ORDER BY score DESC, a.created_at DESC
LIMIT $1 OFFSET $2
`

type SearchArticlesParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Keyword   string      `json:"keyword"`
	IsPublish pgtype.Bool `json:"is_publish"`
}

type SearchArticlesRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Summary      string      `json:"summary"`
	Views        int32       `json:"views"`
	Likes        int32       `json:"likes"`
	IsPublish    bool        `json:"is_publish"`
	Owner        uuid.UUID   `json:"owner"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	DeletedAt    time.Time   `json:"deleted_at"`
	CategoryName pgtype.Text `json:"category_name"`
	Username     pgtype.Text `json:"username"`
	Score        interface{} `json:"score"`
}

func (q *Queries) SearchArticles(ctx context.Context, arg SearchArticlesParams) ([]SearchArticlesRow, error) {
	rows, err := q.db.Query(ctx, searchArticles,
		arg.Limit,
		arg.Offset,
		arg.Keyword,
		arg.IsPublish,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchArticlesRow{}
	for rows.Next() {
		var i SearchArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Views,
			&i.Likes,
			&i.IsPublish,
			&i.Owner,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CategoryName,
			&i.Username,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setArticleDefaultCategoryIdByCategoryId = `-- name: SetArticleDefaultCategoryIdByCategoryId :exec
UPDATE articles SET category_id = 1 WHERE category_id = $1
`

func (q *Queries) SetArticleDefaultCategoryIdByCategoryId(ctx context.Context, categoryID int64) error {
	_, err := q.db.Exec(ctx, setArticleDefaultCategoryIdByCategoryId, categoryID)
	return err
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE articles
SET
    title = COALESCE($1, title),
    summary = COALESCE($2, summary),
    content = COALESCE($3, content),
    is_publish = COALESCE($4, is_publish),
    category_id = COALESCE($5, category_id),
    updated_at = COALESCE($6, updated_at)
WHERE id = $7
RETURNING id, title, summary, content, views, likes, is_publish, owner, created_at, updated_at, deleted_at, category_id
`

type UpdateArticleParams struct {
	Title      pgtype.Text        `json:"title"`
	Summary    pgtype.Text        `json:"summary"`
	Content    pgtype.Text        `json:"content"`
	IsPublish  pgtype.Bool        `json:"is_publish"`
	CategoryID pgtype.Int8        `json:"category_id"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	ID         uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, updateArticle,
		arg.Title,
		arg.Summary,
		arg.Content,
		arg.IsPublish,
		arg.CategoryID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Views,
		&i.Likes,
		&i.IsPublish,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CategoryID,
	)
	return i, err
}
